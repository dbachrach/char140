\section{Implementation}

In this section we describe an implementation of the Hoot protocol we create for our prototype.

\subsection{Generating a Hoot}

The Hoot protocol can be implemented in a variety of ways using different encryption and hashing algorithms. We created a Python prototype that fully implements the protocol.

A Long Tag is generated by running a SHA256 hash over the Plain Tag. The first 128 bits of the Long Tag are dedicated to identification. We then take the first m bytes of the Long Tag to get a Short Tag, where m is the desired Short Tag length.

The Encryption Key is 128 random bits, and the MAC Key is 160 random bits. These random numbers are concatenated together and then encrypted using AES with the last 128 bits of the Long Tag as the key.

The plain text is encrypted using AES with the Encryption Key as the key. An integrity check is created by performing an HMAC-SHA1 of the cipher text and the MAC Key as the key.

With all components created, a Hoot can be generated by printing out a \# symbol,  the short tag, a space, the encrypted keys, the HMAC digest, and the cipher text.

\subsection{Message Length}

Given our goal to conform to Twitter, the final output of a message must be under the 140 character limit. Another goal is to be concise and use as little overhead as possible for the entire encryption process. Twitter has a very broad definition of a character. It is not simply ASCII characters, but UTF-8 as well. Based on the encoding, we can squeeze the encryption into even fewer characters. However, this manipulation has issues since many clients do not conform to UTF-8, and there will be little gain if the plain text itself is written in UTF-8. Our prototype can generate Base64 encoded messages or Unicode messages.

Base64 encoding is simple, universal, yet yields longer message sizes. Given a short tag of length $m$ and a plain text message of length $n$, a Base64 encoded message has

\begin{equation*}
	m + 20 \times \mathit{floor}\left(\frac{n}{16}\right) + 118
\end{equation*}

characters. Assuming a Short Tag of 2 characters, to fit a Base64 encoded message into 140 characters, the plain text message can be at most 31 characters.

A unicode message on the other hand can be much shorter. Given $m$ and $n$, a Unicode encoded message has

\begin{equation*}
	m + 12 \times \mathit{floor}\left(\frac{n}{16}\right) + 64
\end{equation*}

characters. Assuming again a Short Tag of length 2, a Unicode encoded message can fit within 140 characters when the plain text is at most 111 characters. By using Unicode, the Hoot protocol only uses 29 characters of overhead and can handle reasonable length messages. Obviously, if longer messages are needed, multiple Hoots can be posted, but by having such a low overhead, we are getting 79\% utility out of the 140 characters.
