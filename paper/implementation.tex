\section{Implementation}
\label{sec:implementation}

In this section we describe our prototype \hoot implementation, which we
use for performance experiments (see
Section~\ref{sec:experiments}). Additionally, our discussion in this
section helps to illustrate the design choices and trade-offs available
in the \hoot approach.

%\subsection{Generating a Hoot}
\paragraphX{Generating a Hoot}
The \hoot protocol allows for a variety of different encryption,
hashing, and message authentication schemes. Our prototype client,
implemented in Python, takes the following steps to construct a message:
\begin{itemize}
\item Generate a long tag by taking a SHA2-256 hash of the plain
  tag. The first 128 bits of the long tag are used exclusively for the
  short tag; we use a $k$-bit prefix of this string. The remaining 128
  bits are used as the tag key, $k_{\mathrm{tag}}$, to encrypt the
  session keys.
\item Generate a random 128-bit encryption key, $k_{\mathrm{enc}}$,
  \hlfixme{What random number generator are we using?  Hopefully a good
    cryptographic one or hardware random?} and a random 160-bit MAC key,
  $k_{\mathrm{mac}}$\hlfixme{Why 160? Birthday
    attacks don't apply to keys, just hash outputs (and don't apply in
    this case anyway). Maybe Dan can chime in here...}. These keys are
  concatenated together and then encrypted with the tag key using AES in
  counter mode.\hlfixme{I assume that there a fixed initial counter; 0?}
\item Encrypt the plaintext message with $k_{\mathrm{enc}}$ using AES in
  counter mode and use $k_{\mathrm{mac}}$ to generate a HMAC-SHA1
  message authentication code over the encrypted plaintext.
\item Print the message, consisting of a {\tt \#} symbol, the short tag,
  a space, the encrypted keys, the HMAC digest, and the cipher text.
\end{itemize}

We note that the prototype does not currently include a mechanism for
generating collisions between short tags. This would be useful primarily
for the first person to start the group or generate a new plain tag
(effectively resetting the password). We describe a mechanism that
could be used for generating collisions in Section~\ref{sec:collider}.

%To generate collisions, the client should accept as input an existing
%short tag that the user wants her tag to collide with and the prefix to
%be used for the plain tag (rather than the entire plain tag). The
%client could then apply a random sequence of suffix values to the
%prefix, take hashes of the resulting plain tags, and compare the short
%tag derived from each hash with the desired short tag until it finds
%match found. We address the cost to find such a collision in
%Section~\ref{sec:experiments}.

\paragraphX{Message length.}  
We wish to render messages in a format that can be transmitted via
Twitter. The primarily difficulty we face is Twitter's 140 character
limit. We must also ensure that the short tags are rendered in standard
Twitter hashtag format (i.e., preceded with a {\tt \#} character and
followed by whitespace) such that standard Twitter searching mechanisms
will efficiently find them.

Interestingly, Twitter has a very broad definition of a character. Based
on our testing, we believe that Twitter limits tweets to 140 Unicode
(UTF-8) glyphs. While we could certainly take advantage of this to
squeeze the longest possible HooT messages into a single tweet,
particularly if we were willing to restrict \hoot plaintext messages to
7-bit ASCII, we chose not to pursue this for our
implementation. Instead, we went with a standard Base64 encoding (the
letters A-Z, a-z, 0-9, +, and /), getting six bits per glyph.

Assuming a single short tag of two characters (12 bits), the maximum
plain text message with our prototype implementation would be 31
single-byte characters. (We would need 79 glyphs to represent the
message header, including one short tag, leaving 61 glyphs for the
message, which could then be at most 45 bytes of plaintext.

If, however, we were to implement a more efficient Unicode packing, we
could certainly do much better. UTF-8 allows for just over 1 million
values, not all of which are currently in use\footnote{Wikipedia has a
  reasonably good discussion on this topic:
  \url{http://en.wikipedia.org/wiki/UTF-8}.}. As such, a Unicode packer
should be able to achieve 20 bits per glyph. With this, the entire \hoot
header, with one short tag, could be encoded in 26 glyphs, leaving 114
glyphs for the ciphertext. For users used to Twitter's 140-character
length restriction, which also covers the space available for hashtags
that are generally not necessary given the short tag, this is likely to
be reasonable. One could apply compression schemes and limit inputs to
fewer characters to further maximize the amount of data that could be
encoded into a Twitter tweet.

We note that Twitter is not the only microblogging system that we could
leverage for \hoot messages with fewer restrictions. For example, one
could build a \hoot system on top of Google Buzz, which doesn't have
Twitter's 140 character limit.\footnote{The 140 character limit is an
  artifact of Twitter's original intent to support SMS cellular
  telephone messaging as a way of delivering tweets, a design decision
  made in 1985~\cite{latimes-char160}.}
