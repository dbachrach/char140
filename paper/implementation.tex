\section{Implementation}

In this section we describe our prototype HooT implementation.
%
%T \subsection{Generating a Hoot}
%
The HooT protocol allows for a variety of different encryption, hashing, and message authentication schemes. Our prototype, implemented in Python, selected the following parameters:
\begin{itemize}
\item A long tag is generated by running SHA2-256 over the plain tag. The first 128 bits of the long tag are used exclusively for the short tag; we will use a $k$-bit prefix of this string. The remaining 128 bits are used as the tag key, $k_{\mathrm{tag}}$, to encrypt the session keys.
\item The encryption key, $k_{\mathrm{enc}}$ is 128 random bits, and the MAC key, $k_{\mathrm{mac}}$ is 160 random bits. These random numbers are concatenated together and then encrypted using AES, in counter mode, with the tag key.
\item The plaintext message is also encrypted using AES in counter mode. We use HMAC-SHA1 for message integrity checks.
\end{itemize}

With all components created, a Hoot can be generated by printing out a \# symbol,  the short tag, a space, the encrypted keys, the HMAC digest, and the cipher text.

\paragraphX{Message length.}
We wish to render HooTs in a format that can be transmitted via Twitter. The primarily difficulty we face is Twitter's 140 character limit. We must also ensure that the short tags are rendered in standard Twitter hashtag format (i.e., preceded with a {\texttt \#} character and followed by whitespace) such that standard Twitter searching mechanisms will efficiently find them.

Interestingly, Twitter has a very broad definition of a character; Twitter's {\em actual} implementation appears to be that they limit tweets to 140 Unicode (UTF-8) glyphs. While we could certainly take advantage of this to squeeze the longest possible HooT messages into a single tweet, particularly if we were willing to restrict HooT plaintext messages to 7-bit ASCII, we chose not to pursue this for our implementation. Instead, we went with a standard Base64 encoding (the letters A-Z, a-z, 0-9, +, and /), getting six bits per glyph.

Assuming a single short tag of 2 characters (12 bits), the maximum plain text message with our prototype implementation would be 31 single-byte characters. (We would need 79 glyphs to represent the message header, including one short tag, leaving 61 glyphs for the message, which could then be at most 45 bytes of plaintext.

If, however, we were to implement a more efficient Unicode packing, we could certainly do much better. UTF-8 allows for just over 1 million values, not all of which are currently in use\footnote{Wikipedia has a reasonably good discussion on this topic: \url{http://en.wikipedia.org/wiki/UTF-8}}. As such, a Unicode packer should be able to achieve 20 bits per glyph. With this, the entire HooT header, with one short tag, could be encoded in 26 glyphs, leaving 114 glyphs for the ciphertext. Similarly, we could investigate compression schemes, or we could use a different underlying mechanism (e.g., Google Buzz) which doesn't have Twitter's 140 character limit.
