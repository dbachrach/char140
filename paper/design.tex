\section{HooT Design \& Security Analysis}
\label{sec:design-sec}

In this section, we describe the HooT protocol and analyze its security.

\subsection{Design}
\label{sec:design}

We now describe HooT in detail. After giving a brief overview of the
HooT protocol, we describe how hashtags are generated to provide
collisions with other groups and how the message header and body are
constructed to enable efficient searching.
%We also analyze the security of messages.

\paragraphX{Protocol overview.} The HooT protocol consists of a message
header and a message body. The header contains a group identifier
(a Twitter-style hashtag), an encryption key and a MAC key, both
encrypted with a session key, and finally a MAC
over the ciphertext of the message (see
Figure~\ref{fig:hoot-structure}). As in
Twitter, messages do not name their recipients. Anyone who knows the
secret hashtag associated with a HooT can both read the message and
locate the message easily. Rather than attempting to treat every message
posted to Twitter as a potential group message, and thus decrypting the
entire Twitter stream, the protocol places an identifier into every HooT
as a hashtag so a fellow group member can simply search for the
identifier to see all potential messages. With a constant group
identifier, readers can also publicly follow that identifier like any
other hashtag on Twitter.

\paragraphX{Group identifiers.} To create a hashtag for use as the group
identifier, HooT derives a short bitstring from the secret hashtag. We
must do this in such a way as to give an attacker no information about
the shared secret itself. A cryptographic hash function serves this
purpose well.
%Hash functions provide a great way to get a
%set of bits from a shared secret without divulging much information
%about the original shared secret. 
We call the secret hashtag a \textit{plain tag}, which is comparable to
a normal Twitter hashtag, though it should have enough entropy to
prevent the adversary from guessing it. The result of hashing the plain
tag with a given hash function \textit{H} (such as SHA-1) is referred to
as the \textit{long tag}, i.e.:
%
$\id{LongTag} \leftarrow H\left(\id{PlainTag}\right)$.

The HooT protocol could simply use the long tag as an identifier, but
this choice leads to several problems. First, to achieve our design goal
of keeping identifiers short and to fit within Twitter's 140 character
limit, it is less than ideal to use the full output of a hash function
(e.g. 160 bits for SHA-1 or 256 bits for SHA-256). Secondly, strong hash
cryptographic functions produce virtually no collisions for reasonable
numbers of groups. As described in Section~\ref{sec:goals}, we propose
that different groups' identifiers collide with each other for recipient
anonymity and plausible deniability.

To generate a collision, we need to shorten the long tag, generating a
\textit{short tag} of $k$ bits. The short tag will, by design, induce
collisions between unrelated plain tags. The shorter the short tag, the
higher the collision rate will be and the less sure an observer can be
as to what topic a HooT reader is actually following. With this greater
anonymity comes more computational work: since more group messages will
now belong to the same identifier, a follower must download and decrypt
more messages to find the desired ones.
%Depending on the required degree
%of subscriber anonymity, more collisions might be worth the
%computational overhead.
%Effectively, higher collision rates imply better anonymity but require
%downloading larger amounts of other groups' messages as cover
%traffic. 

Given a consistent system-wide short tag length, a group can choose a
tag that will collide with a popular tag, allowing for a predictably
high amount of cover traffic as well as providing a cover story for
followers of that tag.
% For example, if an Egyptian protest group wanted
% to find a collision with Justin Bieber's movie, we perform the following
% calculations:
%
\begin{figure}
\begin{codebox}
\Procname{$\proc{Find-Tag}(\id{prefix}, \id{target}, N, k):$}
\zi \For $i \gets [0,N)$, in random order
\zi \Do
\zi $\id{PlainTag} \gets  \id{prefix}.\id{suffix}$
\zi $\id{ShortTag} \gets H(\id{PlainTag}).\func{bits}(0 \ldots k-1)$
\zi \If $\id{ShortTag} = H(\id{target}).\func{bits}(0 \ldots k-1)$
\zi \Then $\func{return} (\id{PlainTag} , \id{ShortTag})$
\zi \End
\End
\end{codebox}
\caption{Pseudocode for tag collision searching.\label{fig:find-tag}}
\end{figure}

% \begin{align*}
% & \mathit{prefix} \leftarrow  ``\mathrm{\#Tahrir}'' \\
% & \mathit{target} \leftarrow ``\mathrm{\#nsn3d}'' \\
% & \forall_{i \in [0, N)}  \mathit{suffix} \leftarrow i \\
% & \mathit{PlainTag} \leftarrow  \mathit{prefix}.\mathit{suffix} \\
% & \mathit{ShortTag} \leftarrow H({\mathit PlainTag}).\mathrm{bits}(0 \ldots k-1) \\
% & \mathbf{if}\ {\mathit ShortTag} = H(\mathit{target}).\mathrm{bits}(0 \ldots k-1)\\
% & \mathbf{then}\ \mathrm{emit} (\mathit{PlainTag} , {\mathit{ShortTag}}) 
% \end{align*}
%
This algorithm searches for a tag collision, where the \id{PlainTag} suffix is
a number between 0 and $N$, and the \id{ShortTag} is $k$ bits long.
What should be reasonable values for $N$ and $k$?

$k$ determines the length of the \id{ShortTag}. As discussed above, the value for $k$
trades off anonymity versus search overhead for a receiver. $k$ will likely need to be
a constant shared widely across the space of HooT users.

$N$ is bounded by how large a \id{PlainTag} string can be reasonably
passed among potential HooT participants. If the communication of the
\id{PlainTag} must happen by word of mouth, $N$ will be bounded,
perhaps, by the number of digits that can be memorized by most humans
(so, if humans can remember around seven decimal
digits~\cite{miller56}, then $N$ would be $10^7$). Equivalently, we
could search over some other memorizable namespace with suitably high
entropy, like a short string of characters found on a keyboard.
Regardless, the group creator would use \proc{Find-Tag} to search over all possible suffixes to
identify hash collisions. Note that the search should be done
randomly, rather than in-order, to increase the attacker's difficulty
in conducting brute force attacks. 

To further increase the entropy of the secret, the prefix could also be
chosen randomly from a large dictionary. In general, any of a variety of
password-selection techniques could be used for the prefix, including
using pass-phrases consisting of multiple complete
words~\cite{passphrase} and generating mnemonics of memorable sentences
phrases~\cite{mnemonics}. Techniques for generating pronounceable
passwords may be particularly useful in this
context~\cite{gasser}. Although word-of-mouth based on memorization is
the preferred means of communication, we note that plain tags can be
spoken while they are typed into a HooT client, facilitating transfer to
some users who don't care to memorize the tag. Finally, balancing some
risk of password discovery against usability and the risk of brute force
and dictionary attacks, the password may be written down and passed by
hand~\cite{written-passwords}.

\paragraphX{Message header and body.}  
%
In addition to the \id{ShortTag}, the header contains a pair of keys
for message body encryption and integrity verification.

For every message, the pair of session keys is randomly generated. Since we intend
to use efficient symmetric key ciphers and hash-based message authentication
functions, session keys may be selected to be 128 bits each. The session keys
are then encrypted with a {\em tag key} derived from the long tag, using
different bits than the $k$ bits used when truncating it to derive the
short tag. Given a \id{LongTag} of 160 bits, if we assume half of those bits
are used in the \id{ShortTag}, the remaining 80 bits give
us $2^80$ possible keys that an attacker must brute force. In \ref{sec:experiments}
we will show that we will use even fewer than half the bits outputted by a \id{LongTag}, and if
needed, we could always use the remaining long tag bits
to initialize a suitably strong pseudo-random number generator.

In summary, the HooT client takes plaintext message $M$ and a plain tag
({\em PlainTag}) and constructs the HooT messages as follows:
%Putting it all together, starting from a plaintext message $M$ with {\em
%  PlainTag} within it \hl{this sentence doesn't make sense to me}, a
%complete HooT message will be as follows:
%

\begin{figure}
\begin{eqnarray*}
M & \leftarrow & \mathrm{plaintext\ message,\ including} \id{PlainTag}
\\
\id{LongTag} & \leftarrow & H(\id{PlainTag}) \\
\id{ShortTag} & \leftarrow & \id{LongTag}.\func{bits}(0 \ldots k-1) \\
k_{\func{tag}} & \leftarrow & \id{LongTag}.\func{bits}(k \ldots) \\
k_{\func{enc}}, k_{\func{mac}} & \leftarrow & \id{random bits} \\
C & \leftarrow & E_{k_{\func{enc}}}(M) \\
\id{HooT}  & \leftarrow &  \left(\id{ShortTag}, E_{k_{\func{tag}}} \left(k_{\func{enc}}, k_{\func{mac}}\right), \func{MAC}_{k_{\func{mac}}}(C), C\right)
\end{eqnarray*}
\caption{Structure of a HooT message.\label{fig:hoot-structure}}
\end{figure}
%
This technique can be generalized to support multiple plain tags. For
each one, a separate long tag can be generated, resulting in multiple
tag keys ($k_{\func{tag}}$), each of which is used to encrypt the same
session keys. The final HooT would have multiple short tags and multiple
encryptions of the session keys.

\begin{table*}
\caption{This table shows how an individual tweet would become a \hoot by noting the Long Tag, Short Tag, and the final \hoot. Tweet 4 shows how a rebellion group could collide with \#bieber and disguise it's messages.
\label{tab:process}
}
\begin{center}
    \begin{tabular}{ l  l  l  l  l }
	 & Tweet & Long Tag & Short Tag & Hoot \\ \hline
	1 & Its all bout the {\bf \#bieber} 100\%Belieber                                 & {\tt 9txrq71tfn8} &  {\tt 9tx} & {\tt \#9tx Xrtfn}... \\
	2 & Don't be a drag; just be a queen whether you're broke or {\bf \#CharlieSheen} & {\tt 7prQnd121f2} & {\tt 7pr} & {\tt \#7pr n771r}... \\
	3 & {\bf \#free-egypt} We'll meet at the usual, 11pm.                             & {\tt 2p7rtfx9pa1} & {\tt 2p7} & {\tt \#2p7 pp76a}... \\
	4 & {\bf \#free-egypt-9rqt} We'll meet at the usual, 11pm.                        & {\tt 9tx79srpLtt} &  {\tt 9tx}  & {\tt \#9tx 18yyQ}... \\
    \end{tabular}
\end{center}
\end{table*}

For illustration, table \ref{tab:process} shows how a few plain-text tweets would be converted into a corresponding \hoot. 1 and 2 are two regular tweets from popular hashtags: \#bieber and \#CharlieSheen. 3 is a \hoot where receiver anonymity is critical, but it's short tag, 2p7, does not collide with anything else. 4 shows how the same group might alter their plain tag so they can deliberate collide with \#bierber's short tag of 9tx.


\subsection{Security Analysis}
\label{sec:security}

Based on the threat model defined in Section~\ref{sec:threat} and the
system design goals described in Section~\ref{sec:goals}, we now analyze
the security of the proposed HooT protocol.

\paragraphX{Message security.}  
%
We begin with a brief analysis of the security of the message protocol
itself.
%We
%analyze the broader security of the HooT scheme later in
%Section~\ref{sec:something-else}.

First, note that the session keys are generated randomly and
independently for each message, so that two identical plaintext messages
will have different ciphetexts. If the encryption scheme in use requires
an initialization vector (e.g., CBC mode), this could be included in the
message header. For other encryption schemes, such as counter mode, no
IV is necessary and the randomness of the key will ensure the
non-determinism of the ciphertext.

Message integrity is validated with a symmetric-key message
authentication code such as HMAC. Because the MAC is computed over the
ciphertext, and the MAC key is also generated at random, the MAC leaks
absolutely no information about the plaintext. The MAC verification
process also serves the purpose of identifying whether a prospective
message matches the plain tag in question (for which multiple other
plain tags will collide in the short tags), or whether a message is
irrelevant to the user's plain tag search query and should be dropped.

Replay attacks can be defeated by treating the session keys
($k_{\func{enc}}$, $k_{\func{mac}}$) as nonces. It's highly unlikely
that two different messages will share the same session keys.

%Consequently, the basic HooT message encryption scheme appears to be
%sound, with the only obvious weakness being the selection of the plain
%tag.

\paragraphX{Dictionary Attacks and Brute Force.}  
%
Provided an attacker knows a targeted group's prefix and the alphabet
out of which they generate the suffix, our scheme is vulnerable to brute
force.

If we consider the adversary to be a government for example, it would be fair to assume they have
thousands of machines at their disposal for such an attack. It becomes
important, then for a user to pick a plain tag outside reasonable brute
forcing bounds.


\paragraphX{Traffic Analysis.}  
%

\hlfxnote{Sudden increases in a group's membership.}
\hlfxnote{Chris - do you mean for the above to be under Traffic Analysis or in a separate section?}
\hlfixme{Need to discuss all the features and attacks described in
  Section 2, at least briefly.}

