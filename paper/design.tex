\section{HooT Design \& Security Analysis}
\label{sec:design-sec}

In this section, we describe the HooT protocol and analyze its security.

\begin{table*}
\caption{Hoot Process
\label{tab:example}
}
\begin{center}
    \begin{tabular}{ l  l  l  l  l }
	\hline
	 & Tweets & Long Tags & Short Tags & Hoots \\ \hline
	1 & Its all bout the {\bf \#bieber} 100\%Belieber                                 & {\tt 9txrq71tfn8} &  {\tt 9tx} & {\tt \#9tx Xrtfn}... \\
	2 & Don't be a drag; just be a queen whether you're broke or {\bf \#CharlieSheen} & {\tt 7prQnd121f2} & {\tt 7pr} & {\tt \#7pr n771r}... \\
	3 & {\bf \#free-egypt} We'll meet at the usual, 11pm.                             & {\tt 2p7rtfx9pa1} & {\tt 2p7} & {\tt \#2p7 pp76a}... \\
	4 & {\bf \#free-egype-9rqt} We'll meet at the usual, 11pm.                        & {\tt 9tx79srpLtt} &  {\tt 9tx}  & {\tt \#9tx 18yyQ}... \\
    \end{tabular}
\end{center}
\end{table*}

\subsection{Design}
\label{sec:design}

We now describe HooT in detail. After giving a brief overview of the
HooT protocol, we describe how hashtags are generated to provide
collisions with other groups and how the message header and body are
constructed. 
%We also analyze the security of messages.

\paragraphX{Protocol overview.} The HooT protocol consists of a message
header and a message body. The header contains the group identifier (the
hashtag), an encryption key, a MAC Key, and an integrity digest. As in
Twitter, messages do not name their recipients. Anyone who knows the
secret hashtag associated with a HooT can both read the message and
locate the message easily. Rather than attempting to treat every message
posted to Twitter as a potential group message, and thus decrypting the
entire Twitter stream, the protocol places an identifier into every HooT
as a hashtag so a fellow group member can simply search for the
identifier to see all potential messages. With a constant group
identifier, readers can also publicly follow that identifier like any
other hashtag on Twitter.

\paragraphX{Group identifiers.} To create a hashtag for use as the group
identifier, HooT derives a short bitstring from the secret hashtag. We
must do this in such a way as to give an attacker no information about
the shared secret itself. A cryptographic hash function serves this
purpose well.
%Hash functions provide a great way to get a
%set of bits from a shared secret without divulging much information
%about the original shared secret. 
We call the secret hashtag a \textit{plain tag}, which is comparable to
a normal Twitter hashtag, though it should have enough entropy to
prevent the adversary from guessing it. The result of hashing the plain
tag with a given hash function \textit{H} (such as SHA-1) is referred to
as the \textit{long tag}, i.e.:
%
$\mathit{LongTag} \leftarrow H\left(\mathit{PlainTag}\right)$.

The HooT protocol could simply use the long tag as an identifier, but
this choice leads to several problems. First, to achieve our design goal
of keeping identifiers short and to fit within Twitter's 140 character
limit, it is less than ideal to use the full output of a hash function
(e.g. 160 bits for SHA-1 or 256 bits for SHA-256). Secondly, strong hash
cryptographic functions produce virtually no collisions for reasonable
numbers of groups. As described in Section~\ref{sec:goals}, we propose
that different groups' identifiers collide with each other for recipient
anonymity and plausible deniability.

\hlfxnote{The following ideas should be reflected in the intro, not
  here: If a group is communicating in secret, not only do we want to
  protect the content of the communication, but we would like to conceal
  subscription to a particular group. For example, a rebellion group
  wishes to communicate over Twitter using HooTs, but it can be
  dangerous for a supporter of the rebellion to listen and subscribe to
  the identifier of the group. If, however, the identifier of the group
  can collide with the identifier of a popular Internet topic, like
  Justin Bieber or many other such Twitter celebrities, group followers
  can shadow their rebellious activities with other innocent topics.}

To generate a collision, we need to shorten the long tag, generating a
\textit{short tag} of $k$ bits. The short tag will, by design, induce
collisions between unrelated plain tags. The shorter the short tag, the
higher the collision rate will be and the less sure an observer can be
as to what topic a HooT reader is actually following. With this greater
anonymity comes more computational work: since more group messages will
now belong to the same identifier, a follower must download and decrypt
more messages to find the desired ones.
%Depending on the required degree
%of subscriber anonymity, more collisions might be worth the
%computational overhead.
%Effectively, higher collision rates imply better anonymity but require
%downloading larger amounts of other groups' messages as cover
%traffic. 

Given a consistent system-wide short tag length, a group can choose a
tag that will collide with a popular tag, allowing for a predictably
high amount of cover traffic as well as providing a cover story for
followers of that tag.
% For example, if an Egyptian protest group wanted
% to find a collision with Justin Bieber's movie, we perform the following
% calculations:
%
\begin{codebox}
\Procname{$\proc{Find-Tag}(\id{prefix}, \id{target}, N, k)$}:
\zi \For $i \gets [0,N)$, in random order
\zi \Do
\zi $\id{PlainTag} \gets  \id{prefix}.\id{suffix}$
\zi $\id{ShortTag} \gets H(\id{PlainTag}).\mathrm{bits}(0 \ldots k-1)$
\zi \If $\id{ShortTag} = H(\id{target}).\func{bits}(0 \ldots k-1)$
\zi \Then $\func{return} (\id{PlainTag} , \id{ShortTag})$
\zi \End
\End
\end{codebox}

% \begin{align*}
% & \mathit{prefix} \leftarrow  ``\mathrm{\#Tahrir}'' \\
% & \mathit{target} \leftarrow ``\mathrm{\#nsn3d}'' \\
% & \forall_{i \in [0, N)}  \mathit{suffix} \leftarrow i \\
% & \mathit{PlainTag} \leftarrow  \mathit{prefix}.\mathit{suffix} \\
% & \mathit{ShortTag} \leftarrow H({\mathit PlainTag}).\mathrm{bits}(0 \ldots k-1) \\
% & \mathbf{if}\ {\mathit ShortTag} = H(\mathit{target}).\mathrm{bits}(0 \ldots k-1)\\
% & \mathbf{then}\ \mathrm{emit} (\mathit{PlainTag} , {\mathit{ShortTag}}) 
% \end{align*}
%
This algorithm searches for a tag collision, where the \id{PlainTag} suffix is
a number between 0 and $N$, and the \id{ShortTag} is $k$ bits long.
What should be reasonable values for $N$ and $k$?

$k$ determines the length of the \id{ShortTag}. As discussed above, the value for $k$
trades off anonymity versus search overhead for a receiver. $k$ will likely need to be
a constant shared widely across the space of HooT users.

$N$ is bounded by how large a \id{PlainTag} string can be reasonably
passed among potential HooT participants. If the communication of the
\id{PlainTag} must happen by word of mouth, $N$ will be bounded,
perhaps, by the number of digits that can be memorized by most humans
(so, if humans can remember around seven decimal
digits~\cite{miller56}, then $N$ would be $10^7$). Equivalently, we
could search over some other memorizable namespace with suitably high
entropy, like a short string of characters found on a keyboard.
Regardless, the group creator would use \proc{Find-Tag} to search over all possible suffixes to
identify hash collisions. Note that the search should be done
randomly, rather than in-order, to increase the attacker's difficulty
in conducting brute force attacks. 

To further increase the entropy of the secret, the prefix could also be
chosen randomly from a large dictionary. In general, any of a variety of
password-selection techniques could be used for the prefix, including
using pass-phrases consisting of multiple complete
words~\cite{passphrase} and generating mnemonics of memorable sentences
phrases~\cite{mnemonics}. Techniques for generating pronounceable
passwords may be particularly useful in this
context~\cite{gasser}. Although word-of-mouth based on memorization is
the preferred means of communication, we note that plain tags can be
spoken while they are typed into a HooT client, facilitaing transfer to
some users who don't care to memorize the tag. Finally, balancing some
risk of password discovery against usability and the risk of brute force
and dictionary attacks, the password may be written down and passed by
hand~\cite{written-passwords}.

\paragraphX{Message header and body.}  
%
The header of a HooT includes the short tag, to ensure that hashtag
searches can find the message, as well as the necessary information for
somebody who knows the plain tag to properly decrypt and verify the
integrity of the message.\hlfixme{huh?}

To that end, for every message, we generate a pair of random session
keys, one for encryption and one for message integrity. Since we intend
to use efficient symmetric key ciphers and message authentication
functions, session keys may be selected to be 128 bits \hl{actually the
  mac key is 160 bits since it is used for sha1. the encryption key is
  128 bits though.}, \hlfixme{actually you still use 128 bit keys inside
  the hash -- the output is 160 bits. Also, is there some reason not to
  be using HMAC here? It is the standard. -mkw} each. The session keys
are then encrypted with a {\em tag key} derived from the long tag, using
different bits than the $k$ bits used when truncating it to derive the
short tag; the long tag should have plenty of entropy available for our
use. \hlfixme{the prev. statement is not very precise. How much entropy
  do we actually get? Strong cryptographic hash functions would have a
  strong avalanche effect, so each output bit should be independent of
  all other output bits. Thus, you would ideally get all of the entropy
  of the secret hashtag from any subset of sufficiently many bits.}
If we needed more, we could always use the remaining long tag bits
to initialize a suitably strong pseudo-random number generator.

In sum, the HooT client takes plaintext message $M$ and a plain tag
({\em PlainTag}) and constructs the HooT messages as follows:
%Putting it all together, starting from a plaintext message $M$ with {\em
%  PlainTag} within it \hl{this sentence doesn't make sense to me}, a
%complete HooT message will be as follows:
%

\begin{eqnarray*}
\mathit{LongTag} & \leftarrow & H(\mathit{PlainTag}) \\
\mathit{ShortTag} & \leftarrow & \mathit{LongTag}.\mathrm{bits}(0 \ldots k-1) \\
k_{\mathrm{tag}} & \leftarrow & \mathit{LongTag}.\mathrm{bits}(k \ldots) \\
k_{\mathrm{enc}}, k_{\mathrm{mac}} & \leftarrow & \mathit{random bits} \\
C & \leftarrow & E_{k_{\mathrm{enc}}}(M) \\
\mathit{HooT}  & \leftarrow &  \left(\mathit{ShortTag}, E_{k_{\mathrm{tag}}} \left(k_{\mathrm{enc}}, k_{\mathrm{mac}}\right), \mathrm{MAC}_{k_{\mathrm{mac}}}(C), C\right)
\end{eqnarray*}
%
This technique can be generalized to support multiple plain tags. For
each one, a separate long tag can be generated, resulting in multiple
tag keys ($k_\mathrm{tag}$), each of which is used to encrypt the same
session keys. The final HooT would have multiple short tags and multiple
encryptions of the session keys.


\subsection{Security Analysis}
\label{sec:security}

Based on the threat model defined in Section~\ref{sec:threat} and the
system design goals described in Section~\ref{sec:goals}, we now analyze
the security of the proposed HooT protocol.

\paragraphX{Message security.}  
%
We begin with a brief analysis of the security of the message protocol
itself.
%We
%analyze the broader security of the HooT scheme later in
%Section~\ref{sec:something-else}.

First, note that the session keys are generated randomly and
independently for each message, so that two identical plaintext messages
will have different ciphetexts. If the encryption scheme in use requires
an initialization vector (e.g., CBC mode), this could be included in the
message header. For other encryption schemes, such as counter mode, no
IV is necessary and the randomness of the key will ensure the
non-determinism of the ciphertext.

Message integrity is validated with a symmetric-key message
authentication code such as HMAC. Because the MAC is computed over the
ciphertext, and the MAC key is also generated at random, the MAC leaks
absolutely no information about the plaintext. The MAC verification
process also serves the purpose of identifying whether a prospective
message matches the plain tag in question (for which multiple other
plain tags will collide in the short tags), or whether a message is
irrelevant to the user's plain tag search query and should be dropped.

Replay attacks can be defeated by treating the session keys
($k_{\mathrm{enc}}$, $k_{\mathrm{mac}}$) as nonces. It's highly unlikely
that two different messages will share the same session keys.

%Consequently, the basic HooT message encryption scheme appears to be
%sound, with the only obvious weakness being the selection of the plain
%tag.

\paragraphX{Dictionary Attacks and Brute Force.}  
%
Provided an attacker knows a targeted group's prefix and the alphabet
out of which they generate the suffix, our scheme is vulnerable to brute
force.

. If we consider the adversary
to be a government for example, it would be fair to assume they have
thousands of machines at their disposal for such an attack. It becomes
important, then for a user to pick a plain tag outside reasonable brute
forcing bounds.


\paragraphX{Traffic Analysis.}  
%
\hlfxnote{Sudden increases in a group's membership.}

\hlfixme{Need to discuss all the features and attacks described in
  Section 2, at least briefly.}

