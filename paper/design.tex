\section{Design}
\label{sec:design}

The HooT protocol consists of a message header and a message body. The header contains the identifier, Encryption Key, MAC Key, and integrity digest. As with Twitter, messages do not name their recipients. Anyone who knows one or more of the secret hashtags associated with a HooT must be able to read the message, but should also be able to find the message easily. Rather than attempting to treat every message posted to Twitter as a potential group message, and thus decrypting the entire Twitter stream, the protocol places an identifier into every HooT so a fellow group member can simply search for the identifier to see all potential messages. With a constant group identifier, readers can also publicly follow that identifier like any other hashtag on Twitter.

\paragraphX{Group identifiers.}
To create an identifier, we must find a short set of bits that are derivable from the shared secret, but give an attacker little information about the shared secret itself. Hash functions provide a great way to get a set of bits from a shared secret without divulging much information about the original shared secret. In our protocol, the shared secret is called a \textit{plain tag}, which is comparable to a normal Twitter hashtag. The result of hashing the plain tag with a given hash function, \textit{H}, is referred to as the \textit{long tag}, i.e.: $\mathit{LongTag} \leftarrow H\left(\mathit{PlainTag}\right)$.

The protocol could simply use the long tag as an identifier, but this choice leads to several problems. First, to uphold our design goal of being concise and to fit within Twitter's 140 character limit, it is infeasible to use the full output of a hash function. Secondly, strong hash functions do not produce many collisions. If a group is communicating in secret, not only do we want to protect the content of the communication, but we would like to conceal subscription to a particular group. For example, a rebellion group wishes to communicate over Twitter using HooTs, but it can be dangerous for a supporter of the rebellion to listen and subscribe to the identifier of the group. If, however, the identifier of the group can collide with the identifier of a popular Internet topic, like Justin Bieber or many other such Twitter celebrities, group followers can shadow their rebellious activities with other innocent topics. 

To generate a collision, we need to shorten the long tag, generating a \textit{short tag} of $k$ bits, which will, by design, induce collisions between unrelated plain tags. The shorter the short tag, the higher the collision rate will be and the less sure an observer can be as to what topic a HooT reader is actually following. With this greater anonymity comes more computational work; since more group messages will now be belong to the same identifier, a follower must decrypt more messages to find the desired ones. Depending on the required degree of subscriber anonymity, more collisions might be worth the computational overhead (i.e., higher collision rates imply better anonymity but require downloading larger amounts of messages which serve no purpose other than acting as cover traffic). Also, even given a constant short tag length, a group can choose a tag that will collide with a popular tag, allowing for a predictably high amount of cover traffic as well as providing a cover story for follows of that tag. For example, if an Egyptian protest group wanted to find a collision with Justin Bieber's movie:
%
\begin{align*}
& \mathit{prefix} \leftarrow  ``\mathrm{\#Tahrir}'' \\
& \mathit{target} \leftarrow ``\mathrm{\#nsn3d}'' \\
& \forall_{i \in [0, N)}  \mathit{suffix} \leftarrow i \\
& \mathit{PlainTag} \leftarrow  \mathit{prefix}.\mathit{suffix} \\
& \mathit{ShortTag} \leftarrow H({\mathit PlainTag}).\mathrm{bits}(0 \ldots k-1) \\
& \mathbf{if}\ {\mathit ShortTag} = H(\mathit{target}).\mathrm{bits}(0 \ldots k-1)\\
& \mathbf{then}\ \mathrm{emit} (\mathit{PlainTag} , {\mathit{ShortTag}}) 
\end{align*}
%
In this case, the suffix would be a natural number of some humanly memorizable number of digits (i.e., $N$ is probably at most seven digits). Equivalently, we could search over some other humanly memorizable namespace with suitably high entropy. The system would search over all possible suffixes to identify hash collisions. (This process should be done randomly, rather than in-order, to increase the attacker's difficulty in conducting brute force attacks.) This new plain tag could then be spread through human gossip.

\paragraphX{Message header and body.}
The header will include the short tag, to ensure that hashtag searches can find the message. It must also include the necessary information for somebody who knows the plain tag to properly decrypt and verify the integrity of the message. 

To that end, for every message, we derive a random pair of session keys, one for encryption and one for message integrity. (Since we intend to use efficient symmetric key ciphers and message authentication functions, session keys may be selected to be 128 bits, each) The session keys are then encrypted with a {\em tag key} derived from the long tag, using different bits than the $k$ bits used when truncating it to derive the short tag; the long tag has plenty of available entropy for our use. If we needed more, we could always use the remaining long tag bits to initialize a suitably strong pseudo-random number generator.

Putting it all together, starting from a plaintext message $M$ with {\em PlainTag} within it, a complete HooT message will be as follows:
%
\begin{eqnarray*}
\mathit{LongTag} & \leftarrow & H(\mathit{PlainTag}) \\
\mathit{ShortTag} & \leftarrow & \mathit{LongTag}.\mathrm{bits}(0 \ldots k-1) \\
k_{\mathrm{tag}} & \leftarrow & \mathit{LongTag}.\mathrm{bits}(k \ldots) \\
k_{\mathrm{enc}}, k_{\mathrm{mac}} & \leftarrow & \mathit{random bits} \\
C & \leftarrow & E_{k_{\mathrm{enc}}}(M) \\
\mathit{HooT}  & \leftarrow &  \left(\mathit{ShortTag}, E_{k_{\mathrm{tag}}} \left(k_{\mathrm{enc}}, k_{\mathrm{mac}}\right), \mathrm{MAC}_{k_{\mathrm{mac}}}(C), C\right)
\end{eqnarray*}
%
This generalizes to support multiple plain tags. For each one, a separate long tag can be generated, resulting in multiple tag keys ($k_\mathrm{tag}$), each of which is used to encrypt the same session keys. The final HooT would have multiple short tags and multiple encryptions of the session keys.

\paragraphX{Message security analysis.}
Because the session keys are derived at random, two identical plaintext messages will have different ciphetexts. If the encryption scheme in use requires an initialization vector (e.g., CBC mode), this could be included message header. For other encryption schemes like counter mode, no IV will be necessary and the randomness of the key will ensure the non-determinism of the ciphertext.

Message integrity is validated with a symmetric-key message authentication code. Because the MAC is computed over the ciphertext, and the MAC key is also generated at random, the MAC leaks absolutely no information about the plaintext. The MAC verification process also serves the purpose of identifying if a prospective message matches the plain tag in question (for which multiple other plain tags will collide in the short tags), or whether a message is irrelevant to the user's plain tag search query, and should be dropped.

Replay attacks can be defeated by treating the session keys ($k_{\mathrm{enc}}$, $k_{\mathrm{mac}}$) as nonces. It's highly unlikely that two different messages will share the same session keys.

Consequently, the basic HooT message encryption scheme appears to be sound, with the only obvious weakness being the selection of the plain tag. We will analyze the broader security of the HooT scheme later in Section~\ref{sec:something-else}.
