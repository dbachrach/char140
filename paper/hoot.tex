% hoot.tex

% Author: Dustin Bachrach, Christopher Nunu, Dan Wallach, Matt Wright

% Revisions:  28 March 2011

\documentclass{acm_proc_article-sp}

\usepackage{mathptm}
\usepackage{times}

\begin{document}

\numberofauthors{4}

\author{
\alignauthor
	Dustin Bachrach\\
	\affaddr{Department of Computer Science}\\
	\affaddr{Rice University}\\
	\affaddr{Houston, Texas}\\
	\email{ahdustin@gmail.com}	
	
\alignauthor
 	Christopher Nunu\\
	\affaddr{Department of Computer Science}\\
	\affaddr{Rice University}\\
	\affaddr{Houston, Texas}\\
	\email{canunu@gmail.com}
	
\alignauthor
	Dan Wallach\\
	\affaddr{Department of Computer Science}\\
	\affaddr{Rice University}\\
	\affaddr{Houston, Texas}\\
	\email{dwallach@rice.edu}\\

\and
\alignauthor
	Matt Wright\\
	\affaddr{Computer Science and Engineering}\\
	\affaddr{University of Texas at Arlington}\\
	\affaddr{Arlington, Texas}\\
	\email{mwright@cse.uta.edu}
}

\title{Hoot}
\date{May 6th, 2011}

\maketitle

\begin{abstract}

\end{abstract}

\section{Introduction}

- Problem: Twitter like semantics w/ encrypted messages
	- Follow a Hashtag
	- Take hashtag and create something with crytpo strength
	- Something derived from tags you can search on
	- But also deliberate collisions (cover traffic)
	
- Like to have thing that feels like twitter but anonymity properties:

- Twitter/Facebook relevant in Tunisia, (Social media playing big role in revolution accross many countries. govt deliberately shut down)

- While we can't keep them from filtering out service altogether, want to have private communication in plain sight (not stenagraphic)

- Strong crypto usable by people whispering to each other in streets

- Only trusted channel is not electronic (spoken word), to exchange key.


- complimentary to Tor, solve problems Tor+Twitter does not




- What we are doing
-- Define a protocol for users to communicate over an insecure public network like twitter with message confidentiality and subscriber anonymity. 

- Punting on plain tag distribution

- Vocabulary

\section{Background}

1) History of government censorship, man in the middle
	- Tunisia code injection
	- Chinese firewall
	- Crypto keys for important services to iranian source (Komodo)
	- Person providing netwrok (even over ssl) might be evil

2) Tor
	- Trying to work against governent censorship
	
- "Group Crypto Keys"
	
\section{Definitions}

- What is anonymous

- "Cover traffic", "k anonymity"

- Privacy

- Define anonymity
--- Sender anonymity
--- Subscriber anonymity

- Basic Crypto:
	Message auth codes
	Hash Functions
	AES
	Vanilla crypto

\section{Design}

The Hoot protocol consists of a message header and a message body. The header contains the identifier, session key, and integrity digest. Messages are indirect in that they do not reference recipients. Anyone who knows the shared secret must be able to read the message but should also be able to find the message easily. Rather than attempting to treat every message posted to Twitter as a potential group message and thus decrypting the entire Twitter stream, the protocol places an identifier into every Hoot so a fellow group member can simply search for the identifier to see all potential messages. With a constant group identifier, readers can also publicly follow that identifier like any other Hash Tag on Twitter.

To create an identifier, we must find a short set of bits that are derivable from the shared secret, but give an attacker little information about the shared secret itself. Hash functions provide a great way to get a set of bits from a shared secret without divulging much information about the original shared secret. In our protocol, the shared secret is called a Plain Tag, which is comparable to a Twitter Hash Tag. The result of hashing the Plain Tag is the Long Tag. 

The protocol could simply use the Long Tag as an identifier, but this choice leads to several problems. First, to uphold our design goal of being concise and to fit within Twitter's 140 character limit, it is infeasible to use the full output of a hash function. Secondly, strong hash functions do not produce many collisions. If a group is communicating in secret, not only do we want to protect the content of the communication, but we would like to conceal subscription to a particular group. For example, a rebellion group wishes to communicate over Twitter using Hoots, but it can be dangerous for a supporter of the rebellion to listen and subscribe to the identifier of the group. If, however, the identifier of the group can collide with the identifier of a popular Internet topic, like Charlie Sheen, group followers can shadow their rebellious activities 
with other innocent topics. 

To generate a collision, we need to shorten the long tag, generating a Short Tag, which will induce more collisions. The shorter the Short Tag, the higher the collision rate will be and the less sure an observer can be of what topic a Hoot reader is listening to. With this greater anonymity comes more computational work. Since more group messages will now be belong to the same identifier, a follower must decrypt more messages to find relevant signal. Depending on the required degree of subscriber anonymity, more collisions might be worth the computational overhead. Also, even given a constant Short Tag length, a group can choose a tag that will collide with extremely popular tags to generate even more noise. 

The header also contains an set of encrypted keys. To combat replay attacks, the protocol uses a random session key to encrypt the plain text. This session key is then included in the set of keys in the header. The protocol ensures integrity the standard way by including an HMAC of the cipher text. The key to the HMAC function is randomly generated and is included in these set of keys. Finally, the header also contains the integrity digest itself. By including an integrity digest, the protocol allows for quick verification that a message is for a specific group without having to decrypt the message. It also verifies that the Hoot has not been tampered with. To encrypt these set of keys, we exploit the entropy of the Long Tag. Since the identifier for a message is only the first set of bits in the Long Tag, we can use the latter set of bits elsewhere. By encrypting the keys with part of the Long Tag, a reader can easily know the key to decrypt with since it is simply the hash of the Plain Tag, and we also do not require knowledge of two different secrets.

Finally, the message body is encrypted with the session key, and then appended to the message header.

	
% - Confidentiality of a message

% - Identification of a message
% 	- Can hash a hash tag (vocabulary problem)
% 		- Use these terms: plain tag, long tag, short tag
	% - Short tags
	% - Collisions
	% - long tags give us lots of entropy use it for session key for integrity and for identification

% -- Induced collisions

% -- Trade off between more or less collisions

% - 2 Session keys
% -- Session Key (Encryption)
% -- HMAC Key (Integrity)

- What a message looks like
- Crypto equations/sizes

\section{Experiments}

- How long a short tag should be
- Enough cover traffic?

- what that tells us about design parameters of solution

- Then we can conclude that we need this number of bits, etc

- Wrap up all experiments into What can our system do
	- Easy to collide or not to collide (Tune covertraffic)
	- Efficient computer message encryption



\section{Implementation}

- Protocol

-- Session Keys
-- Encryption Session Key: Rand (16 bits)
-- Integrity Session Key: Rand (20 bits)

-- Identification: Sha256 plain tag
--- first 128 bits are used for long tag
--- first n bytes of long tag become short tag

-- Confidentiality: AES (using session key)
-- HMAC: SHA (integrity key)
-- 

\section{Discussion}
1. Can you incrementally roll it out
	- Service provided by twitter or yourself
2. 140 character limit
	- Twitter doesn't have to go too far to have all the metadata for encryption

\section{Incremental Deployment}

\subsection{Message Length}

- Two encoding options
-- Base64
	-- Simple
	-- Universal
	-- Longer message size 
		---m + 20 * (n/16) + 118 
		---m <= 2, n <= 31, yields Hoot <= 140 characters
-- Unicode
	-- Describe Twitter's counting of `characters'
	-- Use to our advantage
	-- Allows normal English character tweets to fit in 140 chars
	-- Shorter message size
	--- 64 + m + 12 * (n / 16)
	--- m <= 2, n <= 111, yields Hoot <= 140 characters
	
	TODO: Actually encrypt our data. avg length? Longest?

\subsection{Pipeline Performance}

- Twitter's stats (http://blog.twitter.com/2011/03/numbers.html):
	-- 140 million tpd
	-max: 6939 hps
	
- All our numbers are using base64 encoding:

Encryption
----------
100,000 hoot encryptions -> 27.631s        3619.123 hps
500,000 hoot encryptions - 137.402s        3638.957 hps
Avg: 3614.531 hps

Decryption
----------
100,000 hoot decryptions -> 6.430s         15552.099 hps
500,000 hoot decryptions - 32.005s         15622.558 hps
Avg: 15587.328 hps

- Given these numbers, a Twitter server could easily encrypt the entire twitter firehose.

- In reality, would probably get less tweets, but this gives us current upper bound

- To be certain that twitter can keep up, add a few nodes and optimize, and will definitely keep up.

- Interesting to note that decryption rate is important on client, since a client is searching tweets to find potential hoots (and may not collaborate w/ twitter)



\section{Discussion}


- Usability
	- use of this protocol (or who would use it)
	- 7+-2, can people remember plain tags (spoken secrets) (phone numbers) (hide crypto key in phone number) (base 10 digit short tags)
	
- would twitter actually do this
	-- Probably not
	-- Twitter wants to know what people are talking about
<<<<<<< HEAD
	-- Honestly, best if twitter doesn't do this, since users can't ``trust'' twitter, encryption is better done on their own machine and results posted to twitter
- use of this protocol (or who would use it)
=======
	-- Honestly, best if twitter doesn't do this, since users can't "trust" twitter, encryption is better done on their own machine and results posted to twitter
		-- Alternate backend, completely different built on distr system. (DHTs, distributed hash table, CHORD, Pastry)
		-- These message are short enough that they can be stored anywhere. Centrlized system (Twitter, Buzz), anything that's publicly searchable (distributed or central)

>>>>>>> 6d693588239d396d942c875b68c8f7b2a2343ccc

\section{Conclusions}



\bibliographystyle{abbrv}
\bibliography{hootâ€“bib}

\balancecolumns{}

\end{document}
